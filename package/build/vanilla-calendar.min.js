/*! name: vanilla-calendar-picker | url: https://github.com/uvarov-frontend/vanilla-calendar-picker */
(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.VanillaCalendar = {}));
})(this, function(exports2) {
  "use strict";var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

  const classes = {
    calendar: "vanilla-calendar",
    calendarDefault: "vanilla-calendar_default",
    calendarMultiple: "vanilla-calendar_multiple",
    calendarMonth: "vanilla-calendar_month",
    calendarYear: "vanilla-calendar_year",
    calendarHidden: "vanilla-calendar_hidden",
    calendarToInput: "vanilla-calendar_to-input",
    calendarToInputTop: "vanilla-calendar_to-input_top",
    calendarToInputBottom: "vanilla-calendar_to-input_bottom",
    controls: "vanilla-calendar-controls",
    grid: "vanilla-calendar-grid",
    gridDisabled: "vanilla-calendar-grid_disabled",
    column: "vanilla-calendar-column",
    columnMonth: "vanilla-calendar-column_month",
    columnYear: "vanilla-calendar-column_year",
    header: "vanilla-calendar-header",
    headerContent: "vanilla-calendar-header__content",
    month: "vanilla-calendar-month",
    monthDisabled: "vanilla-calendar-month_disabled",
    year: "vanilla-calendar-year",
    yearDisabled: "vanilla-calendar-year_disabled",
    arrow: "vanilla-calendar-arrow",
    arrowPrev: "vanilla-calendar-arrow_prev",
    arrowNext: "vanilla-calendar-arrow_next",
    wrapper: "vanilla-calendar-wrapper",
    content: "vanilla-calendar-content",
    week: "vanilla-calendar-week",
    weekDay: "vanilla-calendar-week__day",
    weekDayWeekend: "vanilla-calendar-week__day_weekend",
    days: "vanilla-calendar-days",
    daysSelecting: "vanilla-calendar-days_selecting",
    months: "vanilla-calendar-months",
    monthsSelecting: "vanilla-calendar-months_selecting",
    monthsMonth: "vanilla-calendar-months__month",
    monthsMonthSelected: "vanilla-calendar-months__month_selected",
    monthsMonthDisabled: "vanilla-calendar-months__month_disabled",
    years: "vanilla-calendar-years",
    yearsSelecting: "vanilla-calendar-years_selecting",
    yearsYear: "vanilla-calendar-years__year",
    yearsYearSelected: "vanilla-calendar-years__year_selected",
    yearsYearDisabled: "vanilla-calendar-years__year_disabled",
    time: "vanilla-calendar-time",
    timeContent: "vanilla-calendar-time__content",
    timeHours: "vanilla-calendar-time__hours",
    timeMinutes: "vanilla-calendar-time__minutes",
    timeKeeping: "vanilla-calendar-time__keeping",
    timeRanges: "vanilla-calendar-time__ranges",
    timeRange: "vanilla-calendar-time__range",
    day: "vanilla-calendar-day",
    dayHoverFirst: "vanilla-calendar-day_hover-first",
    dayHoverLast: "vanilla-calendar-day_hover-last",
    dayHoverIntermediate: "vanilla-calendar-day_hover-intermediate",
    daySelectedFirst: "vanilla-calendar-day_selected-first",
    daySelectedLast: "vanilla-calendar-day_selected-last",
    daySelectedIntermediate: "vanilla-calendar-day_selected-intermediate",
    dayPopup: "vanilla-calendar-day__popup",
    dayBtn: "vanilla-calendar-day__btn",
    dayBtnPrev: "vanilla-calendar-day__btn_prev",
    dayBtnNext: "vanilla-calendar-day__btn_next",
    dayBtnToday: "vanilla-calendar-day__btn_today",
    dayBtnSelected: "vanilla-calendar-day__btn_selected",
    dayBtnHover: "vanilla-calendar-day__btn_hover",
    dayBtnDisabled: "vanilla-calendar-day__btn_disabled",
    dayBtnWeekend: "vanilla-calendar-day__btn_weekend",
    dayBtnHoliday: "vanilla-calendar-day__btn_holiday",
    weekNumbers: "vanilla-calendar-week-numbers",
    weekNumbersTitle: "vanilla-calendar-week-numbers__title",
    weekNumbersContent: "vanilla-calendar-week-numbers__content",
    weekNumber: "vanilla-calendar-week-number",
    isFocus: "vanilla-calendar-is-focus"
  };
  const DOMDefault = (styles) => `
	<div class="${styles.header}">
		<#ArrowPrev />
		<div class="${styles.headerContent}">
			<#Month />
			<#Year />
		</div>
		<#ArrowNext />
	</div>
	<div class="${styles.wrapper}">
		<#WeekNumbers />
		<div class="${styles.content}">
			<#Week />
			<#Days />
		</div>
	</div>
	<#ControlTime />
`;
  const DOMMultiple = (styles) => `
	<div class="${styles.controls}">
		<#ArrowPrev />
		<#ArrowNext />
	</div>
	<div class="${styles.grid}">
		<#Multiple>
			<div class="${styles.column}">
				<div class="${styles.header}">
					<div class="${styles.headerContent}">
						<#Month />
						<#Year />
					</div>
				</div>
				<div class="${styles.wrapper}">
					<#WeekNumbers />
					<div class="${styles.content}">
						<#Week />
						<#Days />
					</div>
				</div>
			</div>
		<#/Multiple>
	</div>
	<#ControlTime />
`;
  const DOMMonths = (styles) => `
	<div class="${styles.header}">
		<div class="${styles.headerContent}">
			<#Month />
			<#Year />
		</div>
	</div>
	<div class="${styles.wrapper}">
		<div class="${styles.content}">
			<#Months />
		</div>
	</div>
`;
  const DOMYears = (styles) => `
	<div class="${styles.header}">
		<#ArrowPrev />
		<div class="${styles.headerContent}">
			<#Month />
			<#Year />
		</div>
		<#ArrowNext />
	</div>
	<div class="${styles.wrapper}">
		<div class="${styles.content}">
			<#Years />
		</div>
	</div>
`;
  class DefaultOptionsCalendar {
    constructor() {
      __publicField(this, "isInit", false);
      __publicField(this, "input", false);
      __publicField(this, "type", "default");
      __publicField(this, "months", 2);
      __publicField(this, "jumpMonths", 1);
      __publicField(this, "jumpToSelectedDate", false);
      __publicField(this, "date", {
        min: "1970-01-01",
        max: "2470-12-31",
        today: /* @__PURE__ */ new Date()
      });
      __publicField(this, "settings", {
        lang: "en",
        iso8601: true,
        toggleSelected: true,
        range: {
          min: this.date.min,
          max: this.date.max,
          disablePast: false,
          disableGaps: false,
          disableAllDays: false,
          disableWeekday: void 0,
          disabled: void 0,
          enabled: void 0
        },
        selection: {
          day: "single",
          month: true,
          year: true,
          time: false,
          controlTime: "all",
          stepHours: 1,
          stepMinutes: 1,
          cancelableDay: true
        },
        selected: {
          dates: void 0,
          month: void 0,
          year: void 0,
          holidays: void 0,
          time: void 0
        },
        visibility: {
          theme: "system",
          themeDetect: "html[data-theme]",
          monthShort: true,
          weekNumbers: false,
          weekend: true,
          today: true,
          disabled: false,
          daysOutside: true,
          positionToInput: "left"
        }
      });
      __publicField(this, "locale", {
        months: [],
        weekday: []
      });
      __publicField(this, "sanitizer", (dirtyHtml) => dirtyHtml);
      __publicField(this, "actions", {
        clickDay: null,
        clickWeekNumber: null,
        clickMonth: null,
        clickYear: null,
        clickArrow: null,
        changeTime: null,
        changeToInput: null,
        getDays: null,
        getMonths: null,
        getYears: null,
        initCalendar: null,
        updateCalendar: null,
        destroyCalendar: null,
        showCalendar: null,
        hideCalendar: null
      });
      __publicField(this, "popups", {});
      __publicField(this, "CSSClasses", __spreadValues({}, classes));
      __publicField(this, "DOMTemplates", {
        default: DOMDefault(this.CSSClasses),
        multiple: DOMMultiple(this.CSSClasses),
        month: DOMMonths(this.CSSClasses),
        year: DOMYears(this.CSSClasses)
      });
      __publicField(this, "HTMLElement");
      __publicField(this, "HTMLOriginalElement");
      __publicField(this, "HTMLInputElement");
      __publicField(this, "rangeMin");
      __publicField(this, "rangeMax");
      __publicField(this, "rangeDisabled");
      __publicField(this, "rangeEnabled");
      __publicField(this, "selectedDates");
      __publicField(this, "selectedHolidays");
      __publicField(this, "selectedMonth");
      __publicField(this, "selectedYear");
      __publicField(this, "selectedHours");
      __publicField(this, "selectedMinutes");
      __publicField(this, "selectedKeeping");
      __publicField(this, "selectedTime");
      __publicField(this, "currentType");
      __publicField(this, "correctMonths");
      __publicField(this, "viewYear");
      __publicField(this, "dateMin");
      __publicField(this, "dateMax");
    }
  }
  const getDateString = (date, asUtc = false) => {
    if (asUtc) {
      return date.toISOString().substring(0, 10);
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  };
  const getDate = (date) => /* @__PURE__ */ new Date(`${date}T00:00:00`);
  const parseDates = (dates) => dates.reduce((accumulator, date) => {
    if (date instanceof Date || typeof date === "number") {
      const d = date instanceof Date ? date : new Date(date);
      accumulator.push(d.toISOString().substring(0, 10));
    } else if (date.match(/^(\d{4}-\d{2}-\d{2})$/g)) {
      accumulator.push(date);
    } else {
      date.replace(/(\d{4}-\d{2}-\d{2}).*?(\d{4}-\d{2}-\d{2})/g, (_, startDateStr, endDateStr) => {
        const startDate = getDate(startDateStr);
        const endDate = getDate(endDateStr);
        const currentDate = new Date(startDate.getTime());
        for (currentDate; currentDate <= endDate; currentDate.setDate(currentDate.getDate() + 1)) {
          accumulator.push(getDateString(currentDate));
        }
        return _;
      });
    }
    return accumulator;
  }, []);
  const transformTime12 = (hour) => {
    const hourMap = {
      0: "12",
      13: "01",
      14: "02",
      15: "03",
      16: "04",
      17: "05",
      18: "06",
      19: "07",
      20: "08",
      21: "09",
      22: "10",
      23: "11"
    };
    return hour ? hourMap[Number(hour)] || String(hour) : "";
  };
  const messages = {
    notFoundSelector: (selector) => `${selector} is not found, check the first argument passed to new VanillaCalendar.`,
    notInit: 'The calendar has not been initialized, please initialize it using the "init()" method first.',
    notLocale: 'You specified "define" for "settings.lang" but did not provide the required values for "locale.weekday" or "locale.months".',
    incorrectTheme: 'Incorrect name of theme in "settings.visibility.theme".',
    incorrectTime: "The value of the time property can be: false, true, 12 or 24."
  };
  const initSelectedMonthYear = (self2) => {
    var _a;
    if (self2.jumpToSelectedDate && ((_a = self2.settings.selected.dates) == null ? void 0 : _a.length) && (self2.settings.selected.month === void 0 && self2.settings.selected.year === void 0)) {
      const selectedDate = getDate(parseDates(self2.settings.selected.dates)[0]);
      self2.settings.selected.month = selectedDate.getMonth();
      self2.settings.selected.year = selectedDate.getFullYear();
    }
    const isValidMonth = self2.settings.selected.month !== void 0 && Number(self2.settings.selected.month) >= 0 && Number(self2.settings.selected.month) < 12;
    const isValidYear = self2.settings.selected.year !== void 0 && Number(self2.settings.selected.year) >= 0 && Number(self2.settings.selected.year) <= 9999;
    self2.selectedMonth = isValidMonth ? Number(self2.settings.selected.month) : self2.date.today.getMonth();
    self2.selectedYear = isValidYear ? Number(self2.settings.selected.year) : self2.date.today.getFullYear();
    self2.viewYear = self2.selectedYear;
  };
  const initRange = (self2) => {
    var _a, _b, _c;
    if (self2.settings.range.min === "today") {
      self2.settings.range.min = (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
    }
    if (self2.settings.range.max === "today") {
      self2.settings.range.max = (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
    }
    self2.settings.range.min = getDate(self2.date.min) >= getDate(self2.settings.range.min) ? self2.date.min : self2.settings.range.min;
    self2.settings.range.max = getDate(self2.date.max) <= getDate(self2.settings.range.max) ? self2.date.max : self2.settings.range.max;
    const isDisablePast = self2.settings.range.disablePast && !self2.settings.range.disableAllDays && getDate(self2.settings.range.min) < self2.date.today;
    self2.rangeMin = isDisablePast ? getDateString(self2.date.today) : self2.settings.range.disableAllDays ? getDateString(self2.date.today) : self2.settings.range.min;
    self2.rangeMax = self2.settings.range.disableAllDays ? getDateString(self2.date.today) : self2.settings.range.max;
    self2.rangeDisabled = self2.settings.range.disabled && !self2.settings.range.disableAllDays ? parseDates(self2.settings.range.disabled) : self2.settings.range.disableAllDays ? [self2.rangeMin] : [];
    if (self2.rangeDisabled.length > 1)
      self2.rangeDisabled.sort((a, b) => +new Date(a) - +new Date(b));
    self2.rangeEnabled = self2.settings.range.enabled ? parseDates(self2.settings.range.enabled) : [];
    if (((_a = self2.rangeEnabled) == null ? void 0 : _a[0]) && ((_b = self2.rangeDisabled) == null ? void 0 : _b[0]))
      self2.rangeDisabled = self2.rangeDisabled.filter((d) => !self2.rangeEnabled.includes(d));
    if (self2.rangeEnabled.length > 1)
      self2.rangeEnabled.sort((a, b) => +new Date(a) - +new Date(b));
    if (((_c = self2.rangeEnabled) == null ? void 0 : _c[0]) && self2.settings.range.disableAllDays) {
      self2.rangeMin = self2.rangeEnabled[0];
      self2.rangeMax = self2.rangeEnabled[self2.rangeEnabled.length - 1];
    }
  };
  const initSelectedDates = (self2) => {
    var _a, _b;
    self2.selectedDates = ((_a = self2.settings.selected.dates) == null ? void 0 : _a[0]) ? parseDates(self2.settings.selected.dates) : [];
    self2.selectedHolidays = ((_b = self2.settings.selected.holidays) == null ? void 0 : _b[0]) ? parseDates(self2.settings.selected.holidays) : [];
  };
  const initDateMinMax = (self2) => {
    self2.dateMin = self2.settings.visibility.disabled ? getDate(self2.date.min) : getDate(self2.rangeMin);
    self2.dateMax = self2.settings.visibility.disabled ? getDate(self2.date.max) : getDate(self2.rangeMax);
  };
  const initTime = (self2) => {
    const time12 = self2.settings.selection.time === true || self2.settings.selection.time === 12;
    if (time12 || self2.settings.selection.time === 24) {
      let userTime = false;
      if (typeof self2.settings.selected.time === "string") {
        const regExr = time12 ? /^([0-9]|0[1-9]|1[0-2]):([0-5][0-9])|(AM|PM)/g : /^([0-1]?[0-9]|2[0-3]):([0-5][0-9])/g;
        self2.settings.selected.time.replace(regExr, (_, p1, p2, p3) => {
          if (p1 && p2) {
            userTime = true;
            self2.selectedHours = p1;
            self2.selectedMinutes = p2;
          }
          if (p3 && time12) {
            self2.selectedKeeping = p3;
          } else if (time12) {
            self2.selectedKeeping = "AM";
          }
          return "";
        });
      }
      if (!userTime && time12) {
        self2.selectedHours = transformTime12(String(self2.date.today.getHours()));
        self2.selectedMinutes = String(self2.date.today.getMinutes());
        self2.selectedKeeping = Number(self2.date.today.getHours()) >= 12 ? "PM" : "AM";
      } else if (!userTime) {
        self2.selectedHours = String(self2.date.today.getHours());
        self2.selectedMinutes = String(self2.date.today.getMinutes());
      }
      self2.selectedHours = Number(self2.selectedHours) < 10 ? `0${Number(self2.selectedHours)}` : `${self2.selectedHours}`;
      self2.selectedMinutes = Number(self2.selectedMinutes) < 10 ? `0${Number(self2.selectedMinutes)}` : `${self2.selectedMinutes}`;
      self2.selectedTime = `${self2.selectedHours}:${self2.selectedMinutes}${self2.selectedKeeping ? ` ${self2.selectedKeeping}` : ""}`;
    } else if (self2.settings.selection.time) {
      throw new Error(messages.incorrectTime);
    }
  };
  const initCorrectMonths = (self2) => {
    self2.correctMonths = self2.type === "multiple" ? self2.months === 1 ? 2 : self2.months > 12 ? 12 : self2.months : 1;
  };
  const setVariables = (self2) => {
    self2.currentType = self2.type;
    initSelectedMonthYear(self2);
    initRange(self2);
    initSelectedDates(self2);
    initDateMinMax(self2);
    initTime(self2);
    initCorrectMonths(self2);
  };
  const setVisibilityArrows = ({
    arrowPrev,
    arrowNext,
    isPrevHidden,
    isNextHidden
  }) => {
    arrowPrev.style.visibility = isPrevHidden ? "hidden" : "";
    arrowNext.style.visibility = isNextHidden ? "hidden" : "";
  };
  const visibilityArrows = (self2) => {
    var _a, _b;
    if (self2.currentType === "month")
      return;
    const arrowPrev = (_a = self2.HTMLElement) == null ? void 0 : _a.querySelector(`.${self2.CSSClasses.arrowPrev}`);
    const arrowNext = (_b = self2.HTMLElement) == null ? void 0 : _b.querySelector(`.${self2.CSSClasses.arrowNext}`);
    if (!arrowPrev || !arrowNext)
      return;
    const updateType = {
      default: () => {
        const currentSelectedDate = getDate(getDateString(new Date(self2.selectedYear, self2.selectedMonth, 1)));
        const jumpDateMin = new Date(currentSelectedDate.getTime());
        const jumpDateMax = new Date(currentSelectedDate.getTime());
        jumpDateMin.setMonth(jumpDateMin.getMonth() - self2.jumpMonths);
        jumpDateMax.setMonth(jumpDateMax.getMonth() + self2.jumpMonths);
        if (!self2.settings.selection.year) {
          self2.dateMin.setFullYear(currentSelectedDate.getFullYear());
          self2.dateMax.setFullYear(currentSelectedDate.getFullYear());
        }
        const isPrevHidden = !self2.settings.selection.month || jumpDateMin.getFullYear() < self2.dateMin.getFullYear() || jumpDateMin.getFullYear() === self2.dateMin.getFullYear() && jumpDateMin.getMonth() < self2.dateMin.getMonth();
        const isNextHidden = !self2.settings.selection.month || jumpDateMax.getFullYear() > self2.dateMax.getFullYear() || jumpDateMax.getFullYear() === self2.dateMax.getFullYear() && jumpDateMax.getMonth() > self2.dateMax.getMonth();
        setVisibilityArrows({
          arrowPrev,
          arrowNext,
          isPrevHidden,
          isNextHidden
        });
      },
      year: () => {
        setVisibilityArrows({
          arrowPrev,
          arrowNext,
          isPrevHidden: self2.dateMin.getFullYear() && self2.viewYear - 7 <= self2.dateMin.getFullYear(),
          isNextHidden: self2.dateMax.getFullYear() && self2.viewYear + 7 >= self2.dateMax.getFullYear()
        });
      }
    };
    updateType[self2.currentType === "multiple" ? "default" : self2.currentType]();
  };
  const getWeekNumber = (date, iso8601) => {
    if (!date)
      return null;
    const currentDate = getDate(date);
    const dayNum = iso8601 ? currentDate.getDay() || 7 : currentDate.getDay();
    currentDate.setDate(currentDate.getDate() + 4 - dayNum);
    const yearStart = new Date(currentDate.getFullYear(), 0, 1);
    const weekNumber = Math.ceil(((+currentDate - +yearStart) / 864e5 + 1) / 7);
    return {
      year: currentDate.getFullYear(),
      week: weekNumber
    };
  };
  const handleDay = (date, dayInfo, daysEl, CSSClasses) => {
    const dayBtnEl = daysEl.querySelector(`[data-calendar-day="${date}"]`);
    if (!dayBtnEl)
      return;
    if (dayInfo == null ? void 0 : dayInfo.modifier)
      dayBtnEl.classList.add(...dayInfo.modifier.trim().split(" "));
    if (dayInfo == null ? void 0 : dayInfo.html)
      dayBtnEl.parentElement.innerHTML += `<div class="${CSSClasses}">${dayInfo.html}</div>`;
  };
  const createPopup = (self2, daysEl) => {
    var _a;
    if (!self2.popups)
      return;
    (_a = Object.entries(self2.popups)) == null ? void 0 : _a.forEach(([date, dayInfo]) => handleDay(date, dayInfo, daysEl, self2.CSSClasses.dayPopup));
  };
  const createWeekNumber = (self2, dayEls, index, templateWeekNumberEl, weekNumbersContentEl) => {
    const dayBtnEl = dayEls[index].querySelector(`.${self2.CSSClasses.dayBtn}`);
    const weekNumber = getWeekNumber(dayBtnEl == null ? void 0 : dayBtnEl.dataset.calendarDay, self2.settings.iso8601);
    if (!weekNumber)
      return;
    const weekNumberEl = templateWeekNumberEl.cloneNode(true);
    weekNumberEl.innerText = String(weekNumber.week);
    weekNumberEl.dataset.calendarYearWeek = String(weekNumber.year);
    weekNumbersContentEl.append(weekNumberEl);
  };
  const createWeekNumbers = (self2, firstDayWeek, daysSelectedMonth, weekNumbersEl, daysEl) => {
    if (!self2.settings.visibility.weekNumbers)
      return;
    weekNumbersEl.textContent = "";
    const weekNumbersTitleEl = document.createElement("b");
    weekNumbersTitleEl.className = self2.CSSClasses.weekNumbersTitle;
    weekNumbersTitleEl.innerText = "#";
    weekNumbersEl.append(weekNumbersTitleEl);
    const weekNumbersContentEl = document.createElement("div");
    weekNumbersContentEl.className = self2.CSSClasses.weekNumbersContent;
    weekNumbersEl.append(weekNumbersContentEl);
    const templateWeekNumberEl = document.createElement("button");
    templateWeekNumberEl.type = "button";
    templateWeekNumberEl.className = self2.CSSClasses.weekNumber;
    const dayEls = daysEl.querySelectorAll(`.${self2.CSSClasses.day}`);
    const weeksCount = Math.ceil((firstDayWeek + daysSelectedMonth) / 7);
    for (let i = 0; i < weeksCount; i++) {
      createWeekNumber(self2, dayEls, i === 0 ? 6 : i * 7, templateWeekNumberEl, weekNumbersContentEl);
    }
  };
  const setDisabledDays = (self2, date, dayWeekID) => {
    var _a, _b, _c, _d, _e;
    const isDisableWeekday = (_a = self2.settings.range.disableWeekday) == null ? void 0 : _a.includes(dayWeekID);
    const isDisableAllDaysAndIsRangeEnabled = self2.settings.range.disableAllDays && !!((_b = self2.rangeEnabled) == null ? void 0 : _b[0]);
    if ((isDisableWeekday || isDisableAllDaysAndIsRangeEnabled) && !((_c = self2.rangeEnabled) == null ? void 0 : _c.includes(date)) && !((_d = self2.rangeDisabled) == null ? void 0 : _d.includes(date))) {
      self2.rangeDisabled.push(date);
      (_e = self2.rangeDisabled) == null ? void 0 : _e.sort((a, b) => +new Date(a) - +new Date(b));
    }
  };
  const setDayModifier = (self2, year, dayEl, dayBtnEl, dayWeekID, date, otherMonth) => {
    var _a, _b, _c;
    if (getDate(self2.rangeMin) > getDate(date) || getDate(self2.rangeMax) < getDate(date) || ((_a = self2.rangeDisabled) == null ? void 0 : _a.includes(date)) || !self2.settings.selection.month && otherMonth || !self2.settings.selection.year && getDate(date).getFullYear() !== year) {
      dayBtnEl.classList.add(self2.CSSClasses.dayBtnDisabled);
      dayBtnEl.tabIndex = -1;
    }
    if (self2.settings.visibility.today && getDateString(self2.date.today) === date) {
      dayBtnEl.classList.add(self2.CSSClasses.dayBtnToday);
    }
    if (self2.settings.visibility.weekend && (dayWeekID === 0 || dayWeekID === 6)) {
      dayBtnEl.classList.add(self2.CSSClasses.dayBtnWeekend);
    }
    if ((_b = self2.selectedHolidays) == null ? void 0 : _b.includes(date)) {
      dayBtnEl.classList.add(self2.CSSClasses.dayBtnHoliday);
    }
    if ((_c = self2.selectedDates) == null ? void 0 : _c.includes(date)) {
      dayBtnEl.classList.add(self2.CSSClasses.dayBtnSelected);
      if (self2.selectedDates.length > 1 && self2.settings.selection.day === "multiple-ranged") {
        if (self2.selectedDates[0] === date) {
          dayEl.classList.add(self2.CSSClasses.daySelectedFirst);
        }
        if (self2.selectedDates[self2.selectedDates.length - 1] === date) {
          dayEl.classList.add(self2.CSSClasses.daySelectedLast);
        }
        if (self2.selectedDates[0] !== date && self2.selectedDates[self2.selectedDates.length - 1] !== date) {
          dayEl.classList.add(self2.CSSClasses.daySelectedIntermediate);
        }
      }
    }
  };
  const createDay = (self2, year, daysEl, day, dayWeekID, date, otherMonth, modifier) => {
    const dayEl = document.createElement("div");
    dayEl.className = self2.CSSClasses.day;
    const dayBtnEl = document.createElement("button");
    dayBtnEl.className = `${self2.CSSClasses.dayBtn}${modifier ? ` ${modifier}` : ""}`;
    dayBtnEl.type = "button";
    dayBtnEl.innerText = String(day);
    dayBtnEl.dataset.calendarDay = date;
    const addWeekNumber = () => {
      const weekNumber = getWeekNumber(date, self2.settings.iso8601);
      if (!weekNumber)
        return;
      dayBtnEl.dataset.calendarWeekNumber = String(weekNumber.week);
    };
    if (self2.settings.visibility.weekNumbers)
      addWeekNumber();
    if (otherMonth) {
      if (self2.settings.visibility.daysOutside)
        dayEl.append(dayBtnEl);
    } else {
      dayEl.append(dayBtnEl);
    }
    setDisabledDays(self2, date, dayWeekID);
    setDayModifier(self2, year, dayEl, dayBtnEl, dayWeekID, date, otherMonth);
    daysEl.append(dayEl);
    if (self2.actions.getDays)
      self2.actions.getDays(day, date, dayEl, dayBtnEl, self2);
  };
  const prevMonth = (self2, daysEl, selectedYear, selectedMonth, firstDayWeek) => {
    let day = new Date(selectedYear, selectedMonth, 0).getDate() - (firstDayWeek - 1);
    const year = selectedMonth === 0 ? selectedYear - 1 : selectedYear;
    const month = selectedMonth === 0 ? 12 : selectedMonth < 10 ? `0${selectedMonth}` : selectedMonth;
    for (let i = firstDayWeek; i > 0; i--, day++) {
      const date = `${year}-${month}-${day}`;
      const dayWeekID = getDate(date).getDay();
      createDay(self2, selectedYear, daysEl, day, dayWeekID, date, true, self2.CSSClasses.dayBtnPrev);
    }
  };
  const currentMonth = (self2, daysEl, daysSelectedMonth, selectedYear, selectedMonth) => {
    for (let i = 1; i <= daysSelectedMonth; i++) {
      const day = new Date(selectedYear, selectedMonth, i);
      const date = getDateString(day);
      const dayWeekID = day.getDay();
      createDay(self2, selectedYear, daysEl, i, dayWeekID, date, false, null);
    }
  };
  const nextMonth = (self2, daysEl, daysSelectedMonth, selectedYear, selectedMonth, firstDayWeek) => {
    const currentTotalDays = firstDayWeek + daysSelectedMonth;
    const rowsDays = Math.ceil(currentTotalDays / 7);
    const daysNextMonth = 7 * rowsDays - currentTotalDays;
    const year = selectedMonth + 1 === 12 ? selectedYear + 1 : selectedYear;
    const month = selectedMonth + 1 === 12 ? "01" : selectedMonth + 2 < 10 ? `0${selectedMonth + 2}` : selectedMonth + 2;
    for (let i = 1; i <= daysNextMonth; i++) {
      const day = i < 10 ? `0${i}` : String(i);
      const date = `${year}-${month}-${day}`;
      const dayWeekID = getDate(date).getDay();
      createDay(self2, selectedYear, daysEl, i, dayWeekID, date, true, self2.CSSClasses.dayBtnNext);
    }
  };
  const createDays = (self2) => {
    const daysEls = self2.HTMLElement.querySelectorAll(`.${self2.CSSClasses.days}`);
    const weekNumbersEls = self2.HTMLElement.querySelectorAll(`.${self2.CSSClasses.weekNumbers}`);
    const initDate = new Date(self2.selectedYear, self2.selectedMonth, 1);
    daysEls.forEach((daysEl, index) => {
      const selectedDate = new Date(initDate);
      selectedDate.setMonth(selectedDate.getMonth() + index);
      const selectedMonth = selectedDate.getMonth();
      const selectedYear = selectedDate.getFullYear();
      const firstDay = new Date(selectedYear, selectedMonth, 1);
      const daysSelectedMonth = new Date(selectedYear, selectedMonth + 1, 0).getDate();
      const firstDayWeek = self2.settings.iso8601 ? (firstDay.getDay() !== 0 ? firstDay.getDay() : 7) - 1 : firstDay.getDay();
      if (self2.settings.selection.day)
        daysEl.classList.add(self2.CSSClasses.daysSelecting);
      daysEl.textContent = "";
      prevMonth(self2, daysEl, selectedYear, selectedMonth, firstDayWeek);
      currentMonth(self2, daysEl, daysSelectedMonth, selectedYear, selectedMonth);
      nextMonth(self2, daysEl, daysSelectedMonth, selectedYear, selectedMonth, firstDayWeek);
      createWeekNumbers(self2, firstDayWeek, daysSelectedMonth, weekNumbersEls[index], daysEl);
      createPopup(self2, daysEl);
    });
  };
  const visibilityMonth = (self2, monthEl, index, initDate) => {
    const month = new Date(initDate.setMonth(self2.selectedMonth + index)).getMonth();
    const isSelectionDisabled = self2.settings.selection.month === false || self2.settings.selection.month === "only-arrows";
    monthEl.tabIndex = isSelectionDisabled ? -1 : 0;
    monthEl.classList.toggle(self2.CSSClasses.monthDisabled, isSelectionDisabled);
    monthEl.setAttribute("data-calendar-selected-month", String(month));
    monthEl.innerText = self2.locale.months[month];
  };
  const visibilityYear = (self2, yearEl, index, initDate) => {
    const year = new Date(initDate.setFullYear(self2.selectedYear, self2.selectedMonth + index)).getFullYear();
    const isSelectionDisabled = self2.settings.selection.year === false || self2.settings.selection.year === "only-arrows";
    yearEl.tabIndex = isSelectionDisabled ? -1 : 0;
    yearEl.classList.toggle(self2.CSSClasses.yearDisabled, isSelectionDisabled);
    yearEl.setAttribute("data-calendar-selected-year", String(year));
    yearEl.innerText = String(year);
  };
  const visibilityTitle = (self2) => {
    var _a, _b;
    const monthEls = (_a = self2.HTMLElement) == null ? void 0 : _a.querySelectorAll("[data-calendar-selected-month]");
    const yearEls = (_b = self2.HTMLElement) == null ? void 0 : _b.querySelectorAll("[data-calendar-selected-year]");
    if (!(monthEls == null ? void 0 : monthEls[0]) && (yearEls == null ? void 0 : yearEls[0]))
      return;
    const initDate = new Date(self2.selectedYear, self2.selectedMonth, 1);
    monthEls == null ? void 0 : monthEls.forEach((monthEl, index) => visibilityMonth(self2, monthEl, index, initDate));
    yearEls == null ? void 0 : yearEls.forEach((yearEl, index) => visibilityYear(self2, yearEl, index, initDate));
  };
  const changeMonth = (self2, route) => {
    const jumpDate = getDate(getDateString(new Date(self2.selectedYear, self2.selectedMonth, 1)));
    const routeMap = {
      prev: () => jumpDate.setMonth(jumpDate.getMonth() - self2.jumpMonths),
      next: () => jumpDate.setMonth(jumpDate.getMonth() + self2.jumpMonths)
    };
    routeMap[route]();
    [self2.selectedMonth, self2.selectedYear] = [jumpDate.getMonth(), jumpDate.getFullYear()];
    visibilityTitle(self2);
    visibilityArrows(self2);
    createDays(self2);
  };
  const ArrowPrev = (self2) => `
	<button type="button"
		class="${self2.CSSClasses.arrow} ${self2.CSSClasses.arrowPrev}"
		data-calendar-arrow="prev">
	</button>
`;
  const ArrowNext = (self2) => `
	<button type="button"
		class="${self2.CSSClasses.arrow} ${self2.CSSClasses.arrowNext}"
		data-calendar-arrow="next">
	</button>
`;
  const Month = (self2) => `
	<button type="button"
		class="${self2.CSSClasses.month}"
		data-calendar-selected-month>
	</button>
`;
  const Year = (self2) => `
	<button type="button"
		class="${self2.CSSClasses.year}"
		data-calendar-selected-year>
	</button>
`;
  const Week = (self2) => `
	<div class="${self2.CSSClasses.week}"></div>
`;
  const Days = (self2) => `
	<div class="${self2.CSSClasses.days}"></div>
`;
  const Months = (self2) => `
	<div class="${self2.CSSClasses.months}"></div>
`;
  const Years = (self2) => `
	<div class="${self2.CSSClasses.years}"></div>
`;
  const WeekNumbers = (self2) => self2.settings.visibility.weekNumbers ? `
	<div class="${self2.CSSClasses.weekNumbers}"></div>
` : "";
  const ControlTime = (self2) => self2.settings.selection.time ? `
	<div class="${self2.CSSClasses.time}"></div>
` : "";
  const components = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    ArrowNext,
    ArrowPrev,
    ControlTime,
    Days,
    Month,
    Months,
    Week,
    WeekNumbers,
    Year,
    Years
  }, Symbol.toStringTag, { value: "Module" }));
  const getComponent = (pattern) => components[pattern];
  const DOMParser = (self2, template) => template.replace(/[\n\t]/g, "").replace(/<#(?!\/?Multiple)(.*?)>/g, (_, p1) => {
    const component = getComponent(p1.replace(/[/\s\n\t]/g, ""));
    const htmlStr = component ? component(self2) : "";
    return self2.sanitizer(htmlStr);
  }).replace(/[\n\t]/g, "");
  const MultipleParser = (self2, template) => template.replace(/<#Multiple>(.*?)<#\/Multiple>/g, (_, p1) => {
    let content = "";
    for (let i = 0; i < self2.correctMonths; i++) {
      content += p1;
    }
    return content;
  }).replace(/[\n\t]/g, "");
  const createDOM = (self2, target) => {
    const {
      HTMLElement,
      CSSClasses,
      DOMTemplates,
      type,
      currentType,
      correctMonths
    } = self2;
    const updateGridAndControls = (columnClass, DOMTemplate) => {
      if (!target)
        return;
      const controls = HTMLElement.querySelector(`.${CSSClasses.controls}`);
      if (controls)
        HTMLElement.removeChild(controls);
      const grid = HTMLElement.querySelector(`.${CSSClasses.grid}`);
      grid.classList.add(CSSClasses.gridDisabled);
      const columnElement = target.closest(`.${CSSClasses.column}`);
      columnElement.classList.add(columnClass);
      columnElement.innerHTML = DOMParser(self2, DOMTemplate);
    };
    const typeHandlers = {
      default: () => {
        HTMLElement.classList.add(CSSClasses.calendarDefault);
        HTMLElement.classList.remove(CSSClasses.calendarMonth, CSSClasses.calendarYear);
        HTMLElement.innerHTML = DOMParser(self2, DOMTemplates.default);
      },
      multiple: () => {
        if (!correctMonths)
          return;
        HTMLElement.classList.add(CSSClasses.calendarMultiple);
        HTMLElement.classList.remove(CSSClasses.calendarMonth, CSSClasses.calendarYear);
        HTMLElement.innerHTML = MultipleParser(self2, DOMParser(self2, DOMTemplates.multiple));
      },
      month: () => {
        if (type === "multiple") {
          updateGridAndControls(CSSClasses.columnMonth, DOMTemplates.month);
          return;
        }
        HTMLElement.classList.add(CSSClasses.calendarMonth);
        HTMLElement.classList.remove(CSSClasses.calendarDefault, CSSClasses.calendarYear);
        HTMLElement.innerHTML = DOMParser(self2, DOMTemplates.month);
      },
      year: () => {
        if (type === "multiple") {
          updateGridAndControls(CSSClasses.columnYear, DOMTemplates.year);
          return;
        }
        HTMLElement.classList.add(CSSClasses.calendarYear);
        HTMLElement.classList.remove(CSSClasses.calendarDefault, CSSClasses.calendarMonth);
        HTMLElement.innerHTML = DOMParser(self2, DOMTemplates.year);
      }
    };
    HTMLElement.classList.add(CSSClasses.calendar);
    typeHandlers[currentType]();
  };
  const createYearEl = (self2, templateYearEl, selectedYear, yearDisabled, i) => {
    const yearEl = templateYearEl.cloneNode(false);
    yearEl.className = `${self2.CSSClasses.yearsYear}${selectedYear === i ? ` ${self2.CSSClasses.yearsYearSelected}` : yearDisabled ? ` ${self2.CSSClasses.yearsYearDisabled}` : ""}`;
    yearEl.dataset.calendarYear = String(i);
    yearEl.title = String(i);
    yearEl.innerText = String(i);
    if (yearDisabled)
      yearEl.tabIndex = -1;
    return yearEl;
  };
  const createYears = (self2, target) => {
    const selectedYear = (target == null ? void 0 : target.dataset.calendarSelectedYear) ? Number(target == null ? void 0 : target.dataset.calendarSelectedYear) : self2.selectedYear;
    self2.currentType = "year";
    createDOM(self2, target);
    visibilityTitle(self2);
    visibilityArrows(self2);
    const yearsEl = self2.HTMLElement.querySelector(`.${self2.CSSClasses.years}`);
    if (!self2.settings.selection.year || !yearsEl)
      return;
    yearsEl.classList.add(self2.CSSClasses.yearsSelecting);
    const relationshipID2 = self2.type !== "multiple" ? 0 : self2.selectedYear === selectedYear ? 0 : 1;
    const templateYearEl = document.createElement("button");
    templateYearEl.type = "button";
    for (let i = self2.viewYear - 7; i < self2.viewYear + 8; i++) {
      const yearDisabled = i < self2.dateMin.getFullYear() + relationshipID2 || i > self2.dateMax.getFullYear();
      const yearEl = createYearEl(self2, templateYearEl, selectedYear, yearDisabled, i);
      yearsEl.append(yearEl);
      if (self2.actions.getYears)
        self2.actions.getYears(i, yearEl, self2);
    }
  };
  const handleClickArrow = (self2, event) => {
    const element = event.target;
    const arrowEl = element.closest(`.${self2.CSSClasses.arrow}`);
    if (!arrowEl)
      return;
    if (["default", "multiple"].includes(self2.currentType)) {
      changeMonth(self2, arrowEl.dataset.calendarArrow);
    } else if (self2.currentType === "year" && self2.viewYear !== void 0) {
      self2.viewYear += { prev: -15, next: 15 }[arrowEl.dataset.calendarArrow];
      createYears(self2, event.target);
    }
    if (self2.actions.clickArrow)
      self2.actions.clickArrow(event, self2);
  };
  const handleClickWeekNumber = (self2, event) => {
    var _a;
    if (!self2.settings.visibility.weekNumbers || !self2.actions.clickWeekNumber)
      return;
    const weekNumberEl = event.target.closest(`.${self2.CSSClasses.weekNumber}`);
    const daysToWeeks = (_a = self2.HTMLElement) == null ? void 0 : _a.querySelectorAll("[data-calendar-week-number]");
    if (!weekNumberEl || !daysToWeeks)
      return;
    const weekNumberValue = Number(weekNumberEl.innerText);
    const yearWeek = Number(weekNumberEl.dataset.calendarYearWeek);
    const daysOfThisWeek = Array.from(daysToWeeks).filter((day) => Number(day.dataset.calendarWeekNumber) === weekNumberValue);
    self2.actions.clickWeekNumber(event, weekNumberValue, daysOfThisWeek, yearWeek, self2);
  };
  const capitalizeFirstLetter = (str) => `${str.charAt(0).toUpperCase()}${str.substring(1, str.length)}`.replace(/\./, "");
  const getLocaleWeekday = (self2, i) => {
    const weekday = (/* @__PURE__ */ new Date(`1978-01-0${i + 1}T00:00:00.000Z`)).toLocaleString(self2.settings.lang, { weekday: "short", timeZone: "UTC" });
    self2.locale.weekday.push(capitalizeFirstLetter(weekday));
  };
  const getLocaleMonth = (self2, i) => {
    const month = (/* @__PURE__ */ new Date(`1978-${i + 1 <= 9 ? `0${i + 1}` : i + 1}-01T00:00:00.000Z`)).toLocaleString(self2.settings.lang, { month: "long", timeZone: "UTC" });
    self2.locale.months.push(capitalizeFirstLetter(month));
  };
  const getLocale = (self2) => {
    if (self2.settings.lang === "define" && self2.locale.weekday[6] && self2.locale.months[11])
      return;
    if (self2.settings.lang === "define") {
      throw new Error(messages.notLocale);
    }
    self2.locale.weekday = [];
    self2.locale.months = [];
    for (let i = 0; i < 7; i++)
      getLocaleWeekday(self2, i);
    for (let i = 0; i < 12; i++)
      getLocaleMonth(self2, i);
  };
  const relationshipID = (self2) => {
    if (self2.type !== "multiple")
      return 0;
    const columnEls = self2.HTMLElement.querySelectorAll(`.${self2.CSSClasses.column}`);
    const indexColumn = Array.from(columnEls).findIndex((column) => column.classList.contains(`${self2.CSSClasses.columnMonth}`));
    return indexColumn > 0 ? indexColumn : 0;
  };
  const createMonthEl = (self2, templateMonthEl, selectedMonth, monthTitle, monthDisabled, i) => {
    const monthEl = templateMonthEl.cloneNode(false);
    monthEl.className = `${self2.CSSClasses.monthsMonth}${selectedMonth === i ? ` ${self2.CSSClasses.monthsMonthSelected}` : monthDisabled ? ` ${self2.CSSClasses.monthsMonthDisabled}` : ""}`;
    monthEl.title = monthTitle;
    monthEl.innerText = `${self2.settings.visibility.monthShort ? monthTitle.substring(0, 3) : monthTitle}`;
    monthEl.dataset.calendarMonth = String(i);
    if (monthDisabled)
      monthEl.tabIndex = -1;
    return monthEl;
  };
  const createMonths = (self2, target) => {
    var _a, _b;
    const selectedMonth = (target == null ? void 0 : target.dataset.calendarSelectedMonth) ? Number(target.dataset.calendarSelectedMonth) : self2.selectedMonth;
    const yearEl = (_a = target == null ? void 0 : target.closest(`.${self2.CSSClasses.column}`)) == null ? void 0 : _a.querySelector(`.${self2.CSSClasses.year}`);
    const selectedYear = yearEl ? Number(yearEl.dataset.calendarSelectedYear) : self2.selectedYear;
    self2.currentType = "month";
    createDOM(self2, target);
    visibilityTitle(self2);
    const monthsEl = (_b = self2.HTMLElement) == null ? void 0 : _b.querySelector(`.${self2.CSSClasses.months}`);
    if (!self2.settings.selection.month || !monthsEl)
      return;
    monthsEl.classList.add(self2.CSSClasses.monthsSelecting);
    const activeMonthsID = self2.jumpMonths > 1 ? self2.locale.months.map((_, i) => selectedMonth - self2.jumpMonths * i).concat(self2.locale.months.map((_, i) => selectedMonth + self2.jumpMonths * i)).filter((monthID) => monthID >= 0 && monthID <= 12) : Array.from(Array(12).keys());
    const templateMonthEl = document.createElement("button");
    templateMonthEl.type = "button";
    for (let i = 0; i < 12; i++) {
      const monthTitle = self2.locale.months[i];
      const monthDisabled = i < self2.dateMin.getMonth() + relationshipID(self2) && selectedYear <= self2.dateMin.getFullYear() || i > self2.dateMax.getMonth() + relationshipID(self2) && selectedYear >= self2.dateMax.getFullYear() || i !== selectedMonth && !activeMonthsID.includes(i);
      const monthEl = createMonthEl(self2, templateMonthEl, selectedMonth, monthTitle, monthDisabled, i);
      monthsEl.append(monthEl);
      if (self2.actions.getMonths)
        self2.actions.getMonths(i, monthEl, self2);
    }
  };
  const transformTime24 = (hour, keeping) => {
    const hourMap = {
      0: { AM: "00", PM: "12" },
      1: { AM: "01", PM: "13" },
      2: { AM: "02", PM: "14" },
      3: { AM: "03", PM: "15" },
      4: { AM: "04", PM: "16" },
      5: { AM: "05", PM: "17" },
      6: { AM: "06", PM: "18" },
      7: { AM: "07", PM: "19" },
      8: { AM: "08", PM: "20" },
      9: { AM: "09", PM: "21" },
      10: { AM: "10", PM: "22" },
      11: { AM: "11", PM: "23" },
      12: { AM: "12", PM: "12" }
    };
    return hour && keeping ? hourMap[Number(hour)][keeping] : "";
  };
  const getInputElement = (timeEl, className, name) => timeEl.querySelector(`.${className}${name ? ` input[name="${name}"]` : ""}`);
  const addMouseEvents = (range, input, CSSClass) => {
    range.addEventListener("mouseover", () => input.classList.add(CSSClass));
    range.addEventListener("mouseout", () => input.classList.remove(CSSClass));
  };
  const setTime = (self2, e, value, type) => {
    const typeMap = {
      hours: () => {
        self2.selectedHours = value;
      },
      minutes: () => {
        self2.selectedMinutes = value;
      }
    };
    typeMap[type]();
    self2.selectedTime = `${self2.selectedHours}:${self2.selectedMinutes}${self2.selectedKeeping ? ` ${self2.selectedKeeping}` : ""}`;
    if (self2.actions.changeTime)
      self2.actions.changeTime(e, self2);
    if (self2.input && self2.HTMLInputElement && self2.actions.changeToInput)
      self2.actions.changeToInput(e, self2);
  };
  const changeRange = (self2, range, input, btnKeepingTime, type, max) => {
    range.addEventListener("input", (e) => {
      const inputEl = e.target;
      const value = Number(inputEl.value);
      const valueStr = value < 10 ? `0${value}` : `${value}`;
      if (type !== "hours" || max !== 12) {
        input.value = valueStr;
        setTime(self2, e, valueStr, type);
        return;
      }
      if (value < max && value > 0) {
        input.value = valueStr;
        self2.selectedKeeping = "AM";
        btnKeepingTime.innerText = self2.selectedKeeping;
        setTime(self2, e, valueStr, type);
      } else {
        if (value === 0) {
          self2.selectedKeeping = "AM";
          btnKeepingTime.innerText = "AM";
        } else {
          self2.selectedKeeping = "PM";
          btnKeepingTime.innerText = "PM";
        }
        input.value = transformTime12(inputEl.value);
        setTime(self2, e, transformTime12(inputEl.value), type);
      }
    });
  };
  const changeInput = (self2, range, input, btnKeepingTime, type, max) => {
    input.addEventListener("change", (e) => {
      const inputEl = e.target;
      const value = Number(inputEl.value);
      const valueStr = value < 10 ? `0${value}` : `${value}`;
      if (type === "hours" && max === 12) {
        if (inputEl.value && value <= max && value > 0) {
          inputEl.value = valueStr;
          range.value = transformTime24(valueStr, self2.selectedKeeping);
          setTime(self2, e, valueStr, type);
        } else if (inputEl.value && value < 24 && (value > max || value === 0)) {
          if (value === 0) {
            self2.selectedKeeping = "AM";
            btnKeepingTime.innerText = "AM";
          } else {
            self2.selectedKeeping = "PM";
            btnKeepingTime.innerText = "PM";
          }
          inputEl.value = transformTime12(inputEl.value);
          range.value = valueStr;
          setTime(self2, e, transformTime12(inputEl.value), type);
        } else {
          inputEl.value = self2.selectedHours;
        }
      } else if (inputEl.value && value <= max && value >= 0) {
        inputEl.value = valueStr;
        range.value = valueStr;
        setTime(self2, e, valueStr, type);
      } else if (type === "hours") {
        inputEl.value = self2.selectedHours;
      } else if (type === "minutes") {
        inputEl.value = self2.selectedMinutes;
      }
    });
  };
  const clickBtnKeepingTime = (self2, btnKeepingTime, rangeHours) => {
    btnKeepingTime.addEventListener("click", (e) => {
      self2.selectedKeeping = btnKeepingTime.innerText.includes("AM") ? "PM" : "AM";
      btnKeepingTime.innerText = self2.selectedKeeping;
      rangeHours.value = transformTime24(self2.selectedHours, self2.selectedKeeping);
      setTime(self2, e, self2.selectedHours, "hours");
    });
  };
  const changeTime = (self2, timeEl, keepingTime) => {
    const maxTime = keepingTime === 24 ? 23 : keepingTime || 12;
    const rangeHours = getInputElement(timeEl, self2.CSSClasses.timeRange, "hours");
    const rangeMinutes = getInputElement(timeEl, self2.CSSClasses.timeRange, "minutes");
    const inputHours = getInputElement(timeEl, self2.CSSClasses.timeHours, "hours");
    const inputMinutes = getInputElement(timeEl, self2.CSSClasses.timeMinutes, "minutes");
    const btnKeepingTime = timeEl.querySelector(`.${self2.CSSClasses.timeKeeping}`);
    addMouseEvents(rangeHours, inputHours, self2.CSSClasses.isFocus);
    addMouseEvents(rangeMinutes, inputMinutes, self2.CSSClasses.isFocus);
    changeRange(self2, rangeHours, inputHours, btnKeepingTime, "hours", maxTime);
    changeRange(self2, rangeMinutes, inputMinutes, btnKeepingTime, "minutes", 0);
    changeInput(self2, rangeHours, inputHours, btnKeepingTime, "hours", maxTime);
    changeInput(self2, rangeMinutes, inputMinutes, btnKeepingTime, "minutes", 59);
    if (btnKeepingTime)
      clickBtnKeepingTime(self2, btnKeepingTime, rangeHours);
  };
  const InputTime = (name, CSSClass, value, range) => `
	<label class="${CSSClass}">
		<input type="text"
			name="${name}"
			maxlength="2"
			value="${value}"
			${range ? "disabled" : ""}>
	</label>
`;
  const RangeTime = (name, CSSClass, min, max, step, value) => `
	<label class="${CSSClass}">
		<input type="range"
			name="${name}"
			min="${min}"
			max="${max}"
			step="${step}"
			value="${value}">
	</label>
`;
  const createTime = (self2) => {
    const timeEl = self2.HTMLElement.querySelector(`.${self2.CSSClasses.time}`);
    if (!timeEl)
      return;
    const keepingTime = self2.settings.selection.time === true ? 12 : self2.settings.selection.time;
    const range = self2.settings.selection.controlTime === "range";
    const [minHour, maxHour] = [0, 23];
    const [minMinutes, maxMinutes] = [0, 59];
    timeEl.innerHTML = self2.sanitizer(`
		<div class="${self2.CSSClasses.timeContent}">
			${InputTime("hours", self2.CSSClasses.timeHours, self2.selectedHours, range)}
			${InputTime("minutes", self2.CSSClasses.timeMinutes, self2.selectedMinutes, range)}
			${keepingTime === 12 ? `
			<button type="button" class="${self2.CSSClasses.timeKeeping}"
				${range ? "disabled" : ""}>${self2.selectedKeeping}</button>` : ""}
		</div>
		<div class="${self2.CSSClasses.timeRanges}">
			${RangeTime("hours", self2.CSSClasses.timeRange, minHour, maxHour, self2.settings.selection.stepHours, self2.selectedKeeping ? transformTime24(self2.selectedHours, self2.selectedKeeping) : self2.selectedHours)}
			${RangeTime("minutes", self2.CSSClasses.timeRange, minMinutes, maxMinutes, self2.settings.selection.stepMinutes, self2.selectedMinutes)}
		</div>
	`);
    changeTime(self2, timeEl, keepingTime);
  };
  const createWeekDays = (self2, weekEl, weekday) => {
    const templateWeekDayEl = document.createElement("b");
    weekEl.textContent = "";
    for (let i = 0; i < weekday.length; i++) {
      const weekDayName = weekday[i];
      const weekDayEl = templateWeekDayEl.cloneNode(true);
      weekDayEl.className = `${self2.CSSClasses.weekDay}`;
      weekDayEl.className = `${self2.CSSClasses.weekDay}${self2.settings.visibility.weekend && self2.settings.iso8601 ? i === 5 || i === 6 ? ` ${self2.CSSClasses.weekDayWeekend}` : "" : self2.settings.visibility.weekend && !self2.settings.iso8601 ? i === 0 || i === 6 ? ` ${self2.CSSClasses.weekDayWeekend}` : "" : ""}`;
      weekDayEl.innerText = `${weekDayName}`;
      weekEl.append(weekDayEl);
    }
  };
  const createWeek = (self2) => {
    const weekday = [...self2.locale.weekday];
    if (!weekday[0])
      return;
    if (self2.settings.iso8601)
      weekday.push(weekday.shift());
    const weekEls = self2.HTMLElement.querySelectorAll(`.${self2.CSSClasses.week}`);
    weekEls.forEach((weekEl) => createWeekDays(self2, weekEl, weekday));
  };
  const themes = ["light", "dark", "system"];
  const haveListener = {
    value: false,
    set: () => {
      haveListener.value = true;
    },
    check: () => haveListener.value
  };
  const getTheme = (htmlEl, attr) => themes.find((t) => {
    var _a;
    return t !== "system" && ((_a = htmlEl.getAttribute(attr)) == null ? void 0 : _a.includes(t));
  });
  const setTheme = (htmlEl, theme) => {
    htmlEl.dataset.calendarTheme = theme;
  };
  const trackChangesThemeInSystemSettings = (self2, supportDarkTheme) => {
    const setDataAttrTheme = (event) => setTheme(self2.HTMLElement, event.matches ? "dark" : "light");
    setDataAttrTheme(supportDarkTheme);
    if (self2.settings.visibility.theme !== "system" || haveListener.check())
      return;
    const changeDataAttrTheme = (event) => {
      const calendarEls = document.querySelectorAll(`.${self2.CSSClasses.calendar}`);
      calendarEls == null ? void 0 : calendarEls.forEach((calendarEl) => setTheme(calendarEl, event.matches ? "dark" : "light"));
    };
    if (supportDarkTheme.addEventListener) {
      supportDarkTheme.addEventListener("change", changeDataAttrTheme);
    } else {
      supportDarkTheme.addListener(changeDataAttrTheme);
    }
    haveListener.set();
  };
  const trackChangesThemeInHTMLElement = (self2, htmlEl, attr) => {
    const changes = (mutationsList) => {
      for (let i = 0; i < mutationsList.length; i++) {
        const record = mutationsList[i];
        if (record.attributeName === attr) {
          const activeTheme = getTheme(htmlEl, attr);
          if (activeTheme)
            setTheme(self2.HTMLElement, activeTheme);
          break;
        }
      }
    };
    const observer = new MutationObserver(changes);
    observer.observe(htmlEl, {
      attributes: true
    });
  };
  const detectTheme = (self2, supportDarkTheme) => {
    const detectedThemeEl = self2.settings.visibility.themeDetect ? document.querySelector(self2.settings.visibility.themeDetect) : null;
    if (!detectedThemeEl) {
      trackChangesThemeInSystemSettings(self2, supportDarkTheme);
      return;
    }
    const attr = self2.settings.visibility.themeDetect.replace(/^.*\[(.+)\]/g, (_, p1) => p1);
    const activeTheme = getTheme(detectedThemeEl, attr);
    if (activeTheme) {
      setTheme(self2.HTMLElement, activeTheme);
      trackChangesThemeInHTMLElement(self2, detectedThemeEl, attr);
    } else {
      trackChangesThemeInSystemSettings(self2, supportDarkTheme);
    }
  };
  const changeTheme = (self2) => {
    if (!themes.includes(self2.settings.visibility.theme))
      throw new Error(messages.incorrectTheme);
    if (!(window.matchMedia("(prefers-color-scheme)").media !== "not all")) {
      setTheme(self2.HTMLElement, "light");
      return;
    }
    const mapThemes = {
      light: () => setTheme(self2.HTMLElement, "light"),
      dark: () => setTheme(self2.HTMLElement, "dark"),
      system: () => detectTheme(self2, window.matchMedia("(prefers-color-scheme: dark)"))
    };
    mapThemes[self2.settings.visibility.theme]();
  };
  const create = (self2) => {
    const types = {
      default: () => {
        createWeek(self2);
        createDays(self2);
      },
      multiple: () => {
        createWeek(self2);
        createDays(self2);
      },
      month: () => createMonths(self2),
      year: () => createYears(self2)
    };
    changeTheme(self2);
    getLocale(self2);
    createDOM(self2);
    visibilityTitle(self2);
    visibilityArrows(self2);
    createTime(self2);
    types[self2.currentType]();
  };
  const current = {
    self: null,
    rangeMin: void 0,
    rangeMax: void 0
  };
  const removeHoverEffect = () => {
    var _a;
    if (!((_a = current.self) == null ? void 0 : _a.HTMLElement))
      return;
    const { CSSClasses } = current.self;
    const dayEls = current.self.HTMLElement.querySelectorAll(`.${current.self.CSSClasses.dayBtnHover}`);
    dayEls.forEach((d) => {
      var _a2;
      d.classList.remove(current.self.CSSClasses.dayBtnHover);
      (_a2 = d.parentElement) == null ? void 0 : _a2.classList.remove(CSSClasses.dayHoverIntermediate, CSSClasses.dayHoverFirst, CSSClasses.dayHoverLast);
    });
  };
  const addHoverEffect = (day, firstBtnDayEls, lastBtnDayEls) => {
    var _a, _b, _c;
    if (!((_a = current.self) == null ? void 0 : _a.selectedDates))
      return;
    const formattedDate = getDateString(day);
    const { CSSClasses } = current.self;
    if ((_b = current.self.rangeDisabled) == null ? void 0 : _b.includes(formattedDate))
      return;
    const dayEls = (_c = current.self.HTMLElement) == null ? void 0 : _c.querySelectorAll(`[data-calendar-day="${formattedDate}"]`);
    dayEls == null ? void 0 : dayEls.forEach((d) => {
      var _a2;
      d.classList.add(CSSClasses.dayBtnHover);
      (_a2 = d.parentElement) == null ? void 0 : _a2.classList.add(CSSClasses.dayHoverIntermediate);
    });
    firstBtnDayEls == null ? void 0 : firstBtnDayEls.forEach((d) => {
      var _a2;
      return (_a2 = d.parentElement) == null ? void 0 : _a2.classList.add(CSSClasses.dayHoverFirst);
    });
    lastBtnDayEls == null ? void 0 : lastBtnDayEls.forEach((d) => {
      var _a2;
      return (_a2 = d.parentElement) == null ? void 0 : _a2.classList.add(CSSClasses.dayHoverLast);
    });
  };
  const handleHoverDaysEvent = (e) => {
    var _a;
    if (!e.target || !((_a = current.self) == null ? void 0 : _a.selectedDates))
      return;
    const days = e.target.closest(`.${current.self.CSSClasses.days}`);
    if (!days) {
      removeHoverEffect();
      return;
    }
    const btnDayEl = e.target.closest("[data-calendar-day]");
    if (!btnDayEl)
      return;
    const lastDateString = btnDayEl.dataset.calendarDay;
    const startDate = getDate(current.self.selectedDates[0]);
    const endDate = getDate(lastDateString);
    const firstBtnDayEls = current.self.HTMLElement.querySelectorAll(`[data-calendar-day="${current.self.selectedDates[0]}"]`);
    const lastBtnDayEls = current.self.HTMLElement.querySelectorAll(`[data-calendar-day="${lastDateString}"]`);
    const [firstBtnDayElsCorrect, lastBtnDayElsCorrect] = startDate < endDate ? [firstBtnDayEls, lastBtnDayEls] : [lastBtnDayEls, firstBtnDayEls];
    const [start, end] = startDate < endDate ? [startDate, endDate] : [endDate, startDate];
    removeHoverEffect();
    for (let i = new Date(start); i <= end; i.setDate(i.getDate() + 1)) {
      addHoverEffect(i, firstBtnDayElsCorrect, lastBtnDayElsCorrect);
    }
  };
  const handleCancelSelectionDays = (e) => {
    if (!current.self || e.key !== "Escape")
      return;
    current.self.selectedDates = [];
    current.self.HTMLElement.removeEventListener("mousemove", handleHoverDaysEvent);
    document.removeEventListener("keydown", handleCancelSelectionDays);
    create(current.self);
  };
  const updateDisabledDates = () => {
    var _a, _b, _c;
    if (!((_b = (_a = current.self) == null ? void 0 : _a.selectedDates) == null ? void 0 : _b[0]) || !current.self.rangeDisabled || ((_c = current.self.rangeDisabled) == null ? void 0 : _c.length) < 2)
      return;
    const selectedDate = getDate(current.self.selectedDates[0]);
    const [startDate, endDate] = current.self.rangeDisabled.map((dateStr) => getDate(dateStr)).reduce(([start, end], disabledDate) => [
      selectedDate >= disabledDate ? disabledDate : start,
      selectedDate < disabledDate && end === null ? disabledDate : end
    ], [null, null]);
    if (startDate)
      current.self.rangeMin = getDateString(new Date(startDate.setDate(startDate.getDate() + 1)));
    if (endDate)
      current.self.rangeMax = getDateString(new Date(endDate.setDate(endDate.getDate() - 1)));
  };
  const resetDisabledDates = () => {
    if (!current.self)
      return;
    current.self.rangeMin = current.rangeMin;
    current.self.rangeMax = current.rangeMax;
  };
  const handleDayRangedSelection = (self2, formattedDate) => {
    var _a;
    if (formattedDate) {
      const selectedDateExists = self2.selectedDates.length === 1 && self2.selectedDates[0].includes(formattedDate);
      self2.selectedDates = selectedDateExists && !self2.settings.selection.cancelableDay ? [formattedDate, formattedDate] : selectedDateExists && self2.settings.selection.cancelableDay ? [] : self2.selectedDates.length > 1 ? [formattedDate] : [...self2.selectedDates, formattedDate];
      (_a = self2.selectedDates) == null ? void 0 : _a.sort((a, b) => +new Date(a) - +new Date(b));
    }
    if (self2.settings.range.disableGaps) {
      current.rangeMin = current.rangeMin ? current.rangeMin : self2.rangeMin;
      current.rangeMax = current.rangeMax ? current.rangeMax : self2.rangeMax;
    }
    current.self = self2;
    const selectionHandlers = {
      set: () => {
        self2.HTMLElement.addEventListener("mousemove", handleHoverDaysEvent);
        document.addEventListener("keydown", handleCancelSelectionDays);
        if (self2.settings.range.disableGaps)
          updateDisabledDates();
      },
      reset: () => {
        const [startDate, endDate] = [self2.selectedDates[0], self2.selectedDates[self2.selectedDates.length - 1]];
        self2.selectedDates = self2.selectedDates[0] !== self2.selectedDates[self2.selectedDates.length - 1] ? parseDates([`${startDate}:${endDate}`]) : [self2.selectedDates[0], self2.selectedDates[0]];
        self2.HTMLElement.removeEventListener("mousemove", handleHoverDaysEvent);
        document.removeEventListener("keydown", handleCancelSelectionDays);
        if (self2.settings.range.disableGaps)
          resetDisabledDates();
      }
    };
    selectionHandlers[self2.selectedDates.length === 1 ? "set" : "reset"]();
  };
  const handleDaySelection = (self2, dayBtnEl, multiple) => {
    if (!dayBtnEl.dataset.calendarDay)
      return;
    const selectedDay = dayBtnEl.dataset.calendarDay;
    const isSelected = dayBtnEl.classList.contains(self2.CSSClasses.dayBtnSelected);
    if (isSelected && !self2.settings.selection.cancelableDay)
      return;
    let canToggle = true;
    if (self2.settings.toggleSelected !== void 0) {
      canToggle = typeof self2.settings.toggleSelected === "function" ? self2.settings.toggleSelected(self2) : self2.settings.toggleSelected;
    }
    if (isSelected && !canToggle)
      return;
    self2.selectedDates = isSelected ? self2.selectedDates.filter((date) => date !== selectedDay) : multiple ? [...self2.selectedDates, selectedDay] : [selectedDay];
  };
  const handleClickDay = (self2, event) => {
    var _a;
    const element = event.target;
    const closest = (className) => element.closest(`.${className}`);
    const dayBtnEl = closest(self2.CSSClasses.dayBtn);
    if (!self2.settings.selection.day || !["single", "multiple", "multiple-ranged"].includes(self2.settings.selection.day) || !dayBtnEl)
      return;
    const daySelectionActions = {
      single: () => handleDaySelection(self2, dayBtnEl, false),
      multiple: () => handleDaySelection(self2, dayBtnEl, true),
      "multiple-ranged": () => handleDayRangedSelection(self2, dayBtnEl.dataset.calendarDay)
    };
    daySelectionActions[self2.settings.selection.day]();
    (_a = self2.selectedDates) == null ? void 0 : _a.sort((a, b) => +new Date(a) - +new Date(b));
    if (self2.actions.clickDay)
      self2.actions.clickDay(event, self2);
    const isInitAsInput = self2.input && self2.HTMLInputElement && self2.HTMLElement;
    if (isInitAsInput && self2.actions.changeToInput) {
      self2.actions.changeToInput(
        event,
        self2
      );
    }
    const dayBtnPrevEl = closest(self2.CSSClasses.dayBtnPrev);
    const dayBtnNextEl = closest(self2.CSSClasses.dayBtnNext);
    const actionMapping = {
      prev: () => changeMonth(self2, "prev"),
      next: () => changeMonth(self2, "next"),
      default: () => createDays(self2)
    };
    actionMapping[dayBtnPrevEl ? "prev" : dayBtnNextEl ? "next" : "default"]();
  };
  const getColumnID = (self2, columnClass, personalClass, id, dataAttr) => {
    const columnEls = self2.HTMLElement.querySelectorAll(`.${self2.CSSClasses.column}`);
    const indexColumn = Array.from(columnEls).findIndex((column) => column.classList.contains(columnClass));
    const currentValue = Number(columnEls[indexColumn].querySelector(`.${personalClass}`).getAttribute(dataAttr));
    if (self2.currentType === "month" && indexColumn >= 0)
      return id - indexColumn;
    if (self2.currentType === "year" && self2.selectedYear !== currentValue)
      return id - 1;
    return id;
  };
  const handleItemClick = (self2, event, type, CSSClasses, itemEl) => {
    const actionByType = {
      year: () => {
        var _a, _b;
        return (_b = (_a = self2.actions).clickYear) == null ? void 0 : _b.call(_a, event, self2);
      },
      month: () => {
        var _a, _b;
        return (_b = (_a = self2.actions).clickMonth) == null ? void 0 : _b.call(_a, event, self2);
      }
    };
    const selectByType = {
      year: () => {
        if (self2.type === "multiple") {
          const selectedYear = getColumnID(self2, self2.CSSClasses.columnYear, self2.CSSClasses.year, Number(itemEl.dataset.calendarYear), "data-calendar-selected-year");
          const isBeforeMinDate = self2.selectedMonth < self2.dateMin.getMonth() && selectedYear <= self2.dateMin.getFullYear();
          const isAfterMaxDate = self2.selectedMonth > self2.dateMax.getMonth() && selectedYear >= self2.dateMax.getFullYear();
          const isBeforeMinYear = selectedYear < self2.dateMin.getFullYear();
          const isAfterMaxYear = selectedYear > self2.dateMax.getFullYear();
          if (isBeforeMinDate || isBeforeMinYear) {
            self2.selectedYear = self2.dateMin.getFullYear();
            self2.selectedMonth = self2.dateMin.getMonth();
          } else if (isAfterMaxDate || isAfterMaxYear) {
            self2.selectedYear = self2.dateMax.getFullYear();
            self2.selectedMonth = self2.dateMax.getMonth();
          } else {
            self2.selectedYear = selectedYear;
          }
        } else {
          self2.selectedYear = Number(itemEl.dataset.calendarYear);
        }
      },
      month: () => {
        if (self2.type === "multiple") {
          const selectedMonth = getColumnID(self2, self2.CSSClasses.columnMonth, self2.CSSClasses.month, Number(itemEl.dataset.calendarMonth), "data-calendar-selected-month");
          const column = itemEl.closest(`.${CSSClasses.column}`);
          const year = column.querySelector(`.${self2.CSSClasses.year}`);
          self2.selectedYear = Number(year.dataset.calendarSelectedYear);
          const isBeforeMinDate = selectedMonth < self2.dateMin.getMonth() && self2.selectedYear <= self2.dateMin.getFullYear();
          const isAfterMaxDate = selectedMonth > self2.dateMax.getMonth() && self2.selectedYear >= self2.dateMax.getFullYear();
          if (isBeforeMinDate) {
            self2.selectedMonth = self2.dateMin.getMonth();
          } else if (isAfterMaxDate) {
            self2.selectedMonth = self2.dateMax.getMonth();
          } else {
            self2.selectedMonth = selectedMonth;
          }
        } else {
          self2.selectedMonth = Number(itemEl.dataset.calendarMonth);
        }
      }
    };
    selectByType[type]();
    actionByType[type]();
    self2.currentType = self2.type;
    create(self2);
  };
  const handleClickMonthOrYear = (self2, event, type, CSSClasses) => {
    if (!self2.settings.selection[type])
      return;
    const element = event.target;
    const closest = (className) => element.closest(`.${className}`);
    const headerEl = closest(CSSClasses.header);
    const itemEl = closest(CSSClasses.item);
    const gridEl = closest(self2.CSSClasses.grid);
    const columnEl = closest(self2.CSSClasses.column);
    if (self2.currentType !== type && headerEl) {
      const createByType = {
        year: () => createYears(self2, element),
        month: () => createMonths(self2, element)
      };
      createByType[type]();
    } else if (itemEl) {
      handleItemClick(self2, event, type, CSSClasses, itemEl);
    } else if (self2.currentType === type && headerEl || self2.type === "multiple" && self2.currentType === type && gridEl && !columnEl) {
      self2.currentType = self2.type;
      create(self2);
    }
  };
  const handleClick = (self2) => {
    const handle = (e) => {
      handleClickArrow(self2, e);
      handleClickWeekNumber(self2, e);
      handleClickDay(self2, e);
      handleClickMonthOrYear(self2, e, "month", {
        header: self2.CSSClasses.month,
        item: self2.CSSClasses.monthsMonth,
        column: self2.CSSClasses.columnMonth
      });
      handleClickMonthOrYear(self2, e, "year", {
        header: self2.CSSClasses.year,
        item: self2.CSSClasses.yearsYear,
        column: self2.CSSClasses.columnYear
      });
    };
    self2.HTMLElement.addEventListener("click", handle);
    return () => self2.HTMLElement.removeEventListener("click", handle);
  };
  const reset = (self2, {
    year,
    month,
    dates,
    holidays,
    time
  } = {}) => {
    var _a;
    const previousSelected = __spreadValues({}, self2.settings.selected);
    self2.settings.selected.year = year ? previousSelected.year : self2.selectedYear;
    self2.settings.selected.month = month ? previousSelected.month : self2.selectedMonth;
    self2.settings.selected.holidays = holidays ? previousSelected.holidays : self2.selectedHolidays;
    self2.settings.selected.time = time ? previousSelected.time : self2.selectedTime;
    self2.settings.selected.dates = dates === "only-first" && ((_a = self2.selectedDates) == null ? void 0 : _a[0]) ? [self2.selectedDates[0]] : dates === true ? previousSelected.dates : self2.selectedDates;
    setVariables(self2);
    create(self2);
    self2.settings.selected = previousSelected;
    if (self2.settings.selection.day === "multiple-ranged" && dates)
      handleDayRangedSelection(self2);
  };
  function getOffset(elm) {
    if (!elm || !elm.getBoundingClientRect) {
      return void 0;
    }
    const box = elm.getBoundingClientRect();
    const docElem = document.documentElement;
    return {
      bottom: box.bottom,
      right: box.right,
      top: box.top + window.pageYOffset - docElem.clientTop,
      left: box.left + window.pageXOffset - docElem.clientLeft
    };
  }
  function windowScrollPosition() {
    return {
      left: window.pageXOffset || document.documentElement.scrollLeft || 0,
      top: window.pageYOffset || document.documentElement.scrollTop || 0
    };
  }
  function getViewportDimensions() {
    return {
      vw: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
      vh: Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
    };
  }
  function calculateAvailableSpace(element) {
    var _a, _b;
    let bottom = 0;
    let top = 0;
    let left = 0;
    let right = 0;
    const scrollPosition = windowScrollPosition();
    const elmOffset = getOffset(element);
    const { vh, vw } = getViewportDimensions();
    const pageScrollTop = scrollPosition.top;
    const pageScrollLeft = scrollPosition.left;
    if (elmOffset) {
      const elementOffsetTop = (_a = elmOffset.top) != null ? _a : 0;
      const elementOffsetLeft = (_b = elmOffset.left) != null ? _b : 0;
      top = elementOffsetTop - pageScrollTop;
      left = elementOffsetLeft - pageScrollLeft;
      bottom = vh - (elementOffsetTop - pageScrollTop);
      right = vw - (elementOffsetLeft - pageScrollLeft);
    }
    return { top, bottom, left, right };
  }
  function getAvailablePosition(parentElm, pickerElm) {
    const canShow = { top: true, bottom: true, left: true, right: true };
    const parentPositions = [];
    if (pickerElm && parentElm) {
      const { bottom: spaceBottom, top: spaceTop } = calculateAvailableSpace(parentElm);
      const { top: pickerOffsetTop, left: pickerOffsetLeft } = getOffset(parentElm);
      const { height: pickerHeight, width: pickerWidth } = pickerElm.getBoundingClientRect();
      const { vh, vw } = getViewportDimensions();
      const bodyCenterCoordinate = { x: vw / 2, y: vh / 2 };
      if (pickerOffsetTop < bodyCenterCoordinate.y) {
        parentPositions.push("top");
      }
      if (pickerOffsetTop > bodyCenterCoordinate.y) {
        parentPositions.push("bottom");
      }
      if (pickerOffsetLeft < bodyCenterCoordinate.x) {
        parentPositions.push("left");
      }
      if (pickerOffsetLeft > bodyCenterCoordinate.x) {
        parentPositions.push("right");
      }
      if (pickerHeight > spaceTop) {
        canShow.top = false;
      }
      if (pickerHeight > spaceBottom) {
        canShow.bottom = false;
      }
      if (pickerWidth > pickerOffsetLeft) {
        canShow.left = false;
      }
      if (vw - pickerOffsetLeft < pickerWidth) {
        canShow.right = false;
      }
    }
    return { canShow, parentPositions };
  }
  function findBestPickerPosition(input, calendar) {
    let position = "left";
    if (calendar && input) {
      const { canShow, parentPositions } = getAvailablePosition(input, calendar);
      if (canShow.left && canShow.right) {
        if (canShow.bottom) {
          position = "center";
        } else if (canShow.top) {
          position = ["top", "center"];
        }
      } else {
        if (Array.isArray(parentPositions)) {
          parentPositions[0] = parentPositions[0] === "bottom" ? "top" : "bottom";
          return parentPositions;
        }
        return parentPositions;
      }
    }
    return position;
  }
  const setPositionCalendar = (input, calendar, position, css) => {
    if (input) {
      const pos = position === "auto" ? findBestPickerPosition(input, calendar) : position;
      const getPosition = {
        top: -calendar.offsetHeight,
        bottom: input.offsetHeight,
        left: 0,
        center: input.offsetWidth / 2 - calendar.offsetWidth / 2,
        right: input.offsetWidth - calendar.offsetWidth
      };
      const YPosition = !Array.isArray(pos) ? "bottom" : pos[0];
      const XPosition = !Array.isArray(pos) ? pos : pos[1];
      calendar.classList.add(YPosition === "bottom" ? css.calendarToInputBottom : css.calendarToInputTop);
      const inputRect = input.getBoundingClientRect();
      const scrollLeft = window.scrollX || document.documentElement.scrollLeft;
      const scrollTop = window.scrollY || document.documentElement.scrollTop;
      const top = inputRect.top + scrollTop + getPosition[YPosition];
      const left = inputRect.left + scrollLeft + getPosition[XPosition];
      Object.assign(calendar.style, { left: `${left}px`, top: `${top}px` });
    }
  };
  const handleInput = (self2) => {
    let firstInit = true;
    const cleanup = [];
    self2.HTMLInputElement = self2.HTMLElement;
    const createCalendarToInput = () => {
      const calendar = document.createElement("div");
      calendar.className = `${self2.CSSClasses.calendar} ${self2.CSSClasses.calendarToInput} ${self2.CSSClasses.calendarHidden}`;
      self2.HTMLElement = calendar;
      document.body.append(self2.HTMLElement);
      firstInit = false;
      setTimeout(() => {
        setPositionCalendar(self2.HTMLInputElement, calendar, self2.settings.visibility.positionToInput, self2.CSSClasses);
        self2.show();
      }, 0);
      reset(self2, {
        year: true,
        month: true,
        dates: true,
        holidays: true,
        time: true
      });
      if (self2.actions.initCalendar)
        self2.actions.initCalendar(self2);
      return handleClick(self2);
    };
    const handleResize = () => setPositionCalendar(self2.HTMLInputElement, self2.HTMLElement, self2.settings.visibility.positionToInput, self2.CSSClasses);
    const documentClickEvent = (e) => {
      var _a;
      if (!self2 || e.target === self2.HTMLInputElement || ((_a = self2.HTMLElement) == null ? void 0 : _a.contains(e.target)))
        return;
      if (self2.HTMLInputElement && self2.HTMLElement)
        self2.hide();
      window.removeEventListener("resize", handleResize);
      document.removeEventListener("click", documentClickEvent, { capture: true });
    };
    self2.HTMLInputElement.addEventListener("click", () => {
      if (firstInit) {
        cleanup.push(createCalendarToInput());
      } else {
        setPositionCalendar(self2.HTMLInputElement, self2.HTMLElement, self2.settings.visibility.positionToInput, self2.CSSClasses);
        self2.show();
      }
      window.addEventListener("resize", handleResize);
      document.addEventListener("click", documentClickEvent, { capture: true });
    });
    return () => {
      cleanup.forEach((clean) => clean());
    };
  };
  const init = (self2) => {
    self2.HTMLOriginalElement = self2.HTMLElement.cloneNode(true);
    self2.isInit = true;
    if (self2.input) {
      return handleInput(self2);
    }
    setVariables(self2);
    create(self2);
    if (self2.actions.initCalendar)
      self2.actions.initCalendar(self2);
    return handleClick(self2);
  };
  const update = (self2, {
    year,
    month,
    dates,
    holidays,
    time
  } = {}) => {
    if (!self2.isInit)
      throw new Error(messages.notInit);
    reset(self2, {
      year,
      month,
      dates,
      holidays,
      time
    });
    if (self2.actions.updateCalendar)
      self2.actions.updateCalendar(self2);
  };
  const destroy = (self2) => {
    var _a, _b, _c, _d;
    if (!self2.isInit)
      throw new Error(messages.notInit);
    if (self2.input) {
      (_b = (_a = self2.HTMLElement) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.removeChild(self2.HTMLElement);
      (_c = self2.HTMLInputElement) == null ? void 0 : _c.replaceWith(self2.HTMLOriginalElement);
      self2.HTMLInputElement = void 0;
    } else {
      (_d = self2.HTMLElement) == null ? void 0 : _d.replaceWith(self2.HTMLOriginalElement);
    }
    self2.HTMLElement = self2.HTMLOriginalElement;
    if (self2.actions.destroyCalendar)
      self2.actions.destroyCalendar(self2);
  };
  const show = (self2) => {
    if (!self2.currentType) {
      self2.HTMLElement.click();
      return;
    }
    self2.HTMLElement.classList.remove(self2.CSSClasses.calendarHidden);
    if (self2.actions.showCalendar)
      self2.actions.showCalendar(self2);
  };
  const hide = (self2) => {
    if (!self2.currentType)
      return;
    self2.HTMLElement.classList.add(self2.CSSClasses.calendarHidden);
    if (self2.actions.hideCalendar)
      self2.actions.hideCalendar(self2);
  };
  class VanillaCalendar extends DefaultOptionsCalendar {
    constructor(selector, options) {
      super();
      __publicField(this, "init", () => init(this));
      __publicField(this, "update", (reset2) => update(this, reset2));
      __publicField(this, "destroy", () => destroy(this));
      __publicField(this, "show", () => show(this));
      __publicField(this, "hide", () => hide(this));
      this.HTMLElement = typeof selector === "string" ? document.querySelector(selector) : selector;
      if (!this.HTMLElement)
        throw new Error(messages.notFoundSelector(selector));
      if (!options)
        return;
      const replaceProperties = (original, replacement) => {
        Object.keys(replacement).forEach((key) => {
          if (typeof original[key] === "object" && typeof replacement[key] === "object" && !(replacement[key] instanceof Date)) {
            replaceProperties(original[key], replacement[key]);
          } else {
            original[key] = replacement[key];
          }
        });
      };
      replaceProperties(this, options);
    }
  }
  exports2.VanillaCalendar = VanillaCalendar;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
